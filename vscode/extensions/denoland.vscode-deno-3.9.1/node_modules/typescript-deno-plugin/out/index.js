"use strict";
// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Plugin_instances, _Plugin_project, _Plugin_projectName, _Plugin_getGlobalSettings, _Plugin_getSetting, _Plugin_log;
/** Contains the project settings that have been provided by the extension for
 * each workspace. */
const projectSettings = new Map();
/** The default settings to assume to be true until a configuration message is
 * received from the extension. */
const defaultSettings = {
    cache: null,
    enable: false,
    codeLens: null,
    config: null,
    importMap: null,
    internalDebug: false,
    lint: false,
    path: null,
    suggest: {
        autoImports: true,
        completeFunctionCalls: false,
        names: true,
        paths: true,
        imports: {
            autoDiscover: true,
            hosts: {},
        },
    },
    unstable: false,
};
function updateSettings(project, settings) {
    projectSettings.set(project.getProjectName(), settings);
    // We will update the default settings, which helps ensure that when a plugin
    // is created or re-created, we can assume what the previous settings where
    // until told otherwise.
    Object.assign(defaultSettings, settings.workspace);
}
class Plugin {
    constructor() {
        _Plugin_instances.add(this);
        _Plugin_project.set(this, void 0);
        _Plugin_projectName.set(this, void 0);
        _Plugin_log.set(this, (_msg) => { });
    }
    create(info) {
        const { languageService: ls, project, config } = info;
        __classPrivateFieldSet(this, _Plugin_log, (msg) => project.projectService.logger.info(`[typescript-deno-plugin] ${msg}`), "f");
        __classPrivateFieldSet(this, _Plugin_project, project, "f");
        __classPrivateFieldSet(this, _Plugin_projectName, project.getProjectName(), "f");
        updateSettings(__classPrivateFieldGet(this, _Plugin_project, "f"), config);
        setImmediate(() => {
            __classPrivateFieldGet(this, _Plugin_project, "f").refreshDiagnostics();
        });
        /** Given an object and a method name on that object, call if disabled. */
        const callIfDisabled = (fn, fileNameArg, emptyReturn) => {
            // deno-lint-ignore no-explicit-any
            const target = ls[fn];
            return (...args) => {
                const enabled = fileNameArg !== undefined
                    ? __classPrivateFieldGet(this, _Plugin_instances, "m", _Plugin_getSetting).call(this, args[fileNameArg], "enable")
                    : __classPrivateFieldGet(this, _Plugin_instances, "m", _Plugin_getGlobalSettings).call(this).enable;
                return enabled ? emptyReturn : target.call(ls, ...args);
            };
        };
        // This "mutes" diagnostics for things like tsconfig files.
        const projectGetGlobalProjectErrors = __classPrivateFieldGet(this, _Plugin_project, "f").getGlobalProjectErrors;
        __classPrivateFieldGet(this, _Plugin_project, "f").getGlobalProjectErrors = () => __classPrivateFieldGet(this, _Plugin_instances, "m", _Plugin_getGlobalSettings).call(this).enable
            ? []
            : projectGetGlobalProjectErrors.call(__classPrivateFieldGet(this, _Plugin_project, "f"));
        const projectGetAllProjectErrors = __classPrivateFieldGet(this, _Plugin_project, "f").getAllProjectErrors;
        __classPrivateFieldGet(this, _Plugin_project, "f").getAllProjectErrors = () => __classPrivateFieldGet(this, _Plugin_instances, "m", _Plugin_getGlobalSettings).call(this).enable
            ? []
            : projectGetAllProjectErrors.call(__classPrivateFieldGet(this, _Plugin_project, "f"));
        const commentSelection = callIfDisabled("commentSelection", 0, []);
        const findReferences = callIfDisabled("findReferences", 0, undefined);
        const findRenameLocations = callIfDisabled("findRenameLocations", 0, undefined);
        const getApplicableRefactors = callIfDisabled("getApplicableRefactors", 0, []);
        const getBraceMatchingAtPosition = callIfDisabled("getBraceMatchingAtPosition", 0, []);
        const getBreakpointStatementAtPosition = callIfDisabled("getBreakpointStatementAtPosition", 0, undefined);
        const getCodeFixesAtPosition = callIfDisabled("getCodeFixesAtPosition", 0, []);
        const getCompilerOptionsDiagnostics = callIfDisabled("getCompilerOptionsDiagnostics", undefined, []);
        const getCompletionEntryDetails = callIfDisabled("getCompletionEntryDetails", 0, undefined);
        const getCompletionEntrySymbol = callIfDisabled("getCompletionEntrySymbol", 0, undefined);
        const getCompletionsAtPosition = callIfDisabled("getCompletionsAtPosition", 0, undefined);
        const getDefinitionAndBoundSpan = callIfDisabled("getDefinitionAndBoundSpan", 0, undefined);
        const getDefinitionAtPosition = callIfDisabled("getDefinitionAtPosition", 0, undefined);
        const getDocCommentTemplateAtPosition = callIfDisabled("getDocCommentTemplateAtPosition", 0, undefined);
        const getDocumentHighlights = callIfDisabled("getDocumentHighlights", 0, undefined);
        const getEditsForFileRename = callIfDisabled("getEditsForFileRename", 0, []);
        const getEditsForRefactor = callIfDisabled("getEditsForRefactor", 0, undefined);
        const getEncodedSemanticClassifications = callIfDisabled("getEncodedSemanticClassifications", 0, { spans: [], endOfLineState: 0 });
        const getEncodedSyntacticClassifications = callIfDisabled("getEncodedSyntacticClassifications", 0, { spans: [], endOfLineState: 0 });
        const getImplementationAtPosition = callIfDisabled("getImplementationAtPosition", 0, undefined);
        const getJsxClosingTagAtPosition = callIfDisabled("getJsxClosingTagAtPosition", 0, undefined);
        const getNameOrDottedNameSpan = callIfDisabled("getNameOrDottedNameSpan", 0, undefined);
        const getNavigateToItems = callIfDisabled("getNavigateToItems", undefined, []);
        const getNavigationBarItems = callIfDisabled("getNavigationBarItems", 0, []);
        const getNavigationTree = callIfDisabled("getNavigationTree", 0, {
            text: "",
            kind: "",
            kindModifiers: "",
            spans: [],
            nameSpan: undefined,
        });
        const getOutliningSpans = callIfDisabled("getOutliningSpans", 0, []);
        const getQuickInfoAtPosition = callIfDisabled("getQuickInfoAtPosition", 0, undefined);
        const getReferencesAtPosition = callIfDisabled("getReferencesAtPosition", 0, undefined);
        const getSemanticClassifications = callIfDisabled("getSemanticClassifications", 0, []);
        const getSemanticDiagnostics = callIfDisabled("getSemanticDiagnostics", 0, []);
        const getSignatureHelpItems = callIfDisabled("getSignatureHelpItems", 0, undefined);
        const getSpanOfEnclosingComment = callIfDisabled("getSpanOfEnclosingComment", 0, undefined);
        const getSuggestionDiagnostics = callIfDisabled("getSuggestionDiagnostics", 0, []);
        const getSyntacticDiagnostics = callIfDisabled("getSyntacticDiagnostics", 0, []);
        const getSyntacticClassifications = callIfDisabled("getSyntacticClassifications", 0, []);
        const getTodoComments = callIfDisabled("getTodoComments", 0, []);
        const getTypeDefinitionAtPosition = callIfDisabled("getTypeDefinitionAtPosition", 0, undefined);
        const organizeImports = callIfDisabled("organizeImports", undefined, []);
        const prepareCallHierarchy = callIfDisabled("prepareCallHierarchy", 0, undefined);
        const provideCallHierarchyIncomingCalls = callIfDisabled("provideCallHierarchyIncomingCalls", 0, []);
        const provideCallHierarchyOutgoingCalls = callIfDisabled("provideCallHierarchyOutgoingCalls", 0, []);
        const provideInlayHints = callIfDisabled("provideInlayHints", 0, []);
        const toggleLineComment = callIfDisabled("toggleLineComment", 0, []);
        const toggleMultilineComment = callIfDisabled("toggleMultilineComment", 0, []);
        const uncommentSelection = callIfDisabled("uncommentSelection", 0, []);
        return {
            ...ls,
            commentSelection,
            findReferences,
            findRenameLocations,
            getApplicableRefactors,
            getBraceMatchingAtPosition,
            getBreakpointStatementAtPosition,
            getCodeFixesAtPosition,
            getCompilerOptionsDiagnostics,
            getCompletionEntryDetails,
            getCompletionEntrySymbol,
            getCompletionsAtPosition,
            getDefinitionAndBoundSpan,
            getDefinitionAtPosition,
            getDocCommentTemplateAtPosition,
            getDocumentHighlights,
            getEditsForFileRename,
            getEditsForRefactor,
            getEncodedSemanticClassifications,
            getEncodedSyntacticClassifications,
            getImplementationAtPosition,
            getJsxClosingTagAtPosition,
            getNameOrDottedNameSpan,
            getNavigateToItems,
            getNavigationBarItems,
            getNavigationTree,
            getOutliningSpans,
            getQuickInfoAtPosition,
            getReferencesAtPosition,
            getSemanticClassifications,
            getSemanticDiagnostics,
            getSignatureHelpItems,
            getSpanOfEnclosingComment,
            getSuggestionDiagnostics,
            getSyntacticClassifications,
            getSyntacticDiagnostics,
            getTodoComments,
            getTypeDefinitionAtPosition,
            organizeImports,
            prepareCallHierarchy,
            provideCallHierarchyIncomingCalls,
            provideCallHierarchyOutgoingCalls,
            provideInlayHints,
            toggleLineComment,
            toggleMultilineComment,
            uncommentSelection,
        };
    }
    onConfigurationChanged(settings) {
        __classPrivateFieldGet(this, _Plugin_log, "f").call(this, `onConfigurationChanged(${JSON.stringify(settings)})`);
        updateSettings(__classPrivateFieldGet(this, _Plugin_project, "f"), settings);
        __classPrivateFieldGet(this, _Plugin_project, "f").refreshDiagnostics();
    }
}
_Plugin_project = new WeakMap(), _Plugin_projectName = new WeakMap(), _Plugin_log = new WeakMap(), _Plugin_instances = new WeakSet(), _Plugin_getGlobalSettings = function _Plugin_getGlobalSettings() {
    var _a, _b;
    return (_b = (_a = projectSettings.get(__classPrivateFieldGet(this, _Plugin_projectName, "f"))) === null || _a === void 0 ? void 0 : _a.workspace) !== null && _b !== void 0 ? _b : defaultSettings;
}, _Plugin_getSetting = function _Plugin_getSetting(fileName, key) {
    var _a, _b, _c, _d, _e;
    const settings = projectSettings.get(__classPrivateFieldGet(this, _Plugin_projectName, "f"));
    return (_e = (_c = (_b = (_a = settings === null || settings === void 0 ? void 0 : settings.documents) === null || _a === void 0 ? void 0 : _a[fileName]) === null || _b === void 0 ? void 0 : _b.settings[key]) !== null && _c !== void 0 ? _c : 
    // deno-lint-ignore no-explicit-any
    (_d = settings === null || settings === void 0 ? void 0 : settings.workspace) === null || _d === void 0 ? void 0 : _d[key]) !== null && _e !== void 0 ? _e : defaultSettings[key];
};
function init() {
    console.log(`INIT typescript-deno-plugin`);
    return new Plugin();
}
module.exports = init;
//# sourceMappingURL=index.js.map